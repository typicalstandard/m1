# Оптимизация SQL

### Замена коррелированных подзапросов
- Используйте оконные функции или LATERAL JOIN для уменьшения количества подзапросов и улучшения производительности.

### Индексация
- Создавайте составные индексы по ключевым полям, таким как `item_id`, `update_date`, `order_date`.

### Партционирование
- Разбивайте большие таблицы на разделы (partitions) по датам для уменьшения объема данных.

### Денормализация и материализованные представления
- Добавить в таблицу заказов колонку с ценой товара на момент заказа в случае денормализации.
- Создать материализованное представление для хранения заранее вычисленных агрегатов в случае с материализованными представлениями.

# DWH 

## 1. Архитектура DWH на основе Data Vault 2.0

- **Raw Vault:**  
  При загрузке входящего потока заказов (≈100 000 заказов/день) данные попадают в Raw Vault, где фиксируется каждая операция без обработки.  
  - **Hubs:** Хранение уникальных бизнес-ключей (например, OrderID).  
  - **Links:** Фиксирование связей между сущностями (например, связь заказа с клиентом или заказанными товарами).  
  - **Satellites:** Отслеживание контекстных данных (статус, стоимость, состав заказа) с историей изменений. Каждый спутник снабжается метаданными: например, датой загрузки (`load_date`).

- **Business Vault и PIT/Bridge слои:**  
  На их основе создаются представления, отражающие текущее состояние заказов.  
  - **PIT таблицы** собирают последние версии записей из спутников для каждого заказа.  
  - **Bridge таблицы** могут объединять данные из нескольких спутников для построения "актуальной" таблицы заказов, чтобы иметь возможность «путешествовать» во времени по изменениям.

- **Особенности для активного периода:**  
  В первые 6 месяцев изменения происходят активно, поэтому целесообразно разделить спутники на:  
  - «Активный» спутник для недавних, часто изменяющихся данных.  
  - «Архивный» спутник для редких изменений после активного периода (2–5 лет).  
  Такое разделение позволит оптимизировать запросы, обращающиеся к «текущей» информации, и не сканировать всю историю.

## 2. Выделяемые сущности и их роль

- **Hub_Orders:**  
  - Содержит уникальные идентификаторы заказов (OrderID) и базовые атрибуты, общие для всех изменений.
  
- **Hub_Customers (при необходимости):**  
  - Содержит бизнес-ключ клиента, что позволяет связывать заказ с клиентом.

- **Hub_Products / Hub_OrderItems и дополнительные Hubs:**  
  - Если требуется детальное отслеживание товаров в заказе.

- **Satellite_Order_Details:**  
  - Хранит все изменяющиеся атрибуты заказа (например, сумма) с датами загрузки.  
  - Позволяет сохранять историю изменений.

- **Satellite_Order_Status:**  
  - Если статус заказа меняется независимо от другого контекста.

- **Link_OrderCustomer, Link_OrderItems:**  
  - Фиксируют связи между заказами и другими сущностями (товарами).

- **PIT (Point-In-Time) таблица:**  
  - Используется для быстрого доступа к «последней» версии данных из спутников.

## 3. Обновление актуального состояния заказов без `updated_at`

- **Использование `load_date` **  
  При загрузке данных в Raw Vault каждому событию присваивается `load_date` .  
  - При построении PIT-таблиц применяется агрегация по OrderID для выбора записи с максимальным `load_date` в соответствующем спутнике.
  
- **Периодическая ETL-обновляемая выборка:**  
  Формирование «актуального» представления заказов может происходить посредством пакетного обновления:  
  - Из спутников выбирается максимум по `load_date` для каждого заказа.  
  - Этот результат агрегируется в Bridge или отдельную таблицу «актуальных заказов».

## 4. Оптимизация работы 

- **Партционирование:**  
  - Партционируйте спутники (и даже PIT таблицы) по временным периодам (например, по датам или месяцам).  
  - Это ускоряет выборки – особенно для актуальных данных, которые находятся в недавно загруженных разделах.

- **Индексация:**  
  - Создавайте составные индексы по ключевым колонкам (OrderID, load_date, и др.), чтобы выборка последних версий записей происходила эффективно.

- **Инкрементальный процесс обновления:**  
  - Организуйте инкрементальные ETL-процессы для периодического обновления актуальных представлений на основе свежих событий из Raw Vault.

- **Материализованные представления:**  
  - Если запросы к актуальному состоянию заказов очень часты, можно создать материализованное представление (или кэш) для «актуальной» таблицы заказов, что снизит нагрузку на хранилище при запросах.

- **Разделение активных и архивных данных:**  
  - Как уже упоминалось, более частые изменения фиксировать в отдельном «активном» спутнике.  
  - После периода высокой активности данные могут перемещаться в менее требовательное к обновлению хранилище, что оптимизирует общую производительность.

